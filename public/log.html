<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Orbitmate Server ë¡œê·¸ ë·°ì–´</title>
    <link rel="stylesheet" href="/css/log.css" />
  </head>
  <body>
    <div class="header">
      <h1>ğŸš€ Orbitmate Server ë¡œê·¸ ë·°ì–´</h1>

      <div class="status">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="statusText">ì—°ê²° ì¤‘...</span>
      </div>

      <div class="controls">
        <select id="levelFilter">
          <option value="all">ëª¨ë“  ë ˆë²¨</option>
          <option value="INFO">INFO</option>
          <option value="ERROR">ERROR</option>
          <option value="WARN">WARN</option>
        </select>

        <input
          type="text"
          id="searchInput"
          placeholder="ê²€ìƒ‰..."
          maxlength="100"
        />

        <select id="linesLimit">
          <option value="100">ìµœê·¼ 100ì¤„</option>
          <option value="500" selected>ìµœê·¼ 500ì¤„</option>
          <option value="1000">ìµœê·¼ 1000ì¤„</option>
        </select>

        <button id="autoScrollBtn" class="active">ìë™ìŠ¤í¬ë¡¤</button>
        <button id="clearBtn">ì§€ìš°ê¸°</button>
        <button id="refreshBtn">ìƒˆë¡œê³ ì¹¨</button>
        <button id="downloadBtn">ë‹¤ìš´ë¡œë“œ</button>
      </div>
    </div>

    <div class="main-container">
      <div class="log-container">
        <div class="log-content" id="logContent">
          <div class="loading">ë¡œê·¸ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
        </div>
      </div>

      <div class="sidebar">
        <div class="connection-status disconnected" id="connectionStatus">
          ì—°ê²° ìƒíƒœ: ëŠì–´ì§
        </div>

        <div class="stats-section">
          <h3>ğŸ“Š ë¡œê·¸ í†µê³„</h3>
          <div class="stat-item">
            <span>ì´ ë¡œê·¸ ìˆ˜:</span>
            <span class="stat-value" id="totalLogs">0</span>
          </div>
          <div class="stat-item">
            <span>INFO:</span>
            <span class="stat-value" id="infoCount">0</span>
          </div>
          <div class="stat-item">
            <span>ERROR:</span>
            <span class="stat-value" id="errorCount">0</span>
          </div>
          <div class="stat-item">
            <span>WARN:</span>
            <span class="stat-value" id="warnCount">0</span>
          </div>
        </div>

        <div class="stats-section">
          <h3>ğŸ”§ ì‹œìŠ¤í…œ ì •ë³´</h3>
          <div class="stat-item">
            <span>ë©”ëª¨ë¦¬ ë¡œê·¸:</span>
            <span class="stat-value" id="memoryCount">0</span>
          </div>
          <div class="stat-item">
            <span>í•„í„° ìƒíƒœ:</span>
            <span class="stat-value" id="filterStatus">ì—†ìŒ</span>
          </div>
        </div>

        <div class="export-section">
          <h3>ğŸ“ ë‚´ë³´ë‚´ê¸°</h3>
          <button id="exportBtn">í˜„ì¬ ë¡œê·¸ ë‚´ë³´ë‚´ê¸°</button>
        </div>
      </div>
    </div>

    <script>
      let eventSource = null;
      let autoScroll = true;
      let allLogs = [];
      let filteredLogs = [];

      // DOM ìš”ì†Œ ì°¸ì¡°
      const logContent = document.getElementById("logContent");
      const levelFilter = document.getElementById("levelFilter");
      const searchInput = document.getElementById("searchInput");
      const linesLimit = document.getElementById("linesLimit");
      const autoScrollBtn = document.getElementById("autoScrollBtn");
      const clearBtn = document.getElementById("clearBtn");
      const refreshBtn = document.getElementById("refreshBtn");
      const downloadBtn = document.getElementById("downloadBtn");
      const exportBtn = document.getElementById("exportBtn");
      const statusIndicator = document.getElementById("statusIndicator");
      const statusText = document.getElementById("statusText");
      const connectionStatus = document.getElementById("connectionStatus");

      // ë¡œê·¸ ë©”ì‹œì§€ íŒŒì‹± ë° í¬ë§¤íŒ… í•¨ìˆ˜ (ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ê°•í™”)
      function parseAndFormatLogMessage(message) {
        console.log("ğŸ” parseAndFormatLogMessage í˜¸ì¶œ:", message);

        // ì…ë ¥ê°’ ê²€ì¦ ë° ë¬¸ìì—´ ë³€í™˜
        if (typeof message !== "string") {
          if (message && typeof message === "object") {
            // ê°ì²´ì¸ ê²½ìš° message í”„ë¡œí¼í‹°ê°€ ìˆëŠ”ì§€ í™•ì¸
            message = message.message || JSON.stringify(message);
          } else {
            message = String(message || "");
          }
        }

        // íƒ€ì„ìŠ¤íƒ¬í”„ íŒ¨í„´: [2025-06-30T05:35:34.559Z] (ISO í˜•ì‹)
        const timestampRegex = /^\[([^\]]+)\]/;
        const timestampMatch = message.match(timestampRegex);

        if (!timestampMatch) {
          // íƒ€ì„ìŠ¤íƒ¬í”„ê°€ ì—†ëŠ” ê²½ìš° - ìš°ì„  ë ˆë²¨ íŒ¨í„´ë¶€í„° ê²€ì‚¬
          const trimmed = message.trim();
          if (/^(RESPONSE:|TIMEOUT:)/i.test(trimmed)) {
            return {
              timestamp: null,
              level: "INFO",
              message: trimmed,
              formatted: formatLogLine(null, "INFO", trimmed),
            };
          }
          if (/^INFO:/i.test(trimmed)) {
            return {
              timestamp: null,
              level: "INFO",
              message: trimmed,
              formatted: formatLogLine(null, "INFO", trimmed),
            };
          }
          if (/^WARN:/i.test(trimmed)) {
            return {
              timestamp: null,
              level: "WARN",
              message: trimmed,
              formatted: formatLogLine(null, "WARN", trimmed),
            };
          }
          if (/^ERROR:/i.test(trimmed)) {
            return {
              timestamp: null,
              level: "ERROR",
              message: trimmed,
              formatted: formatLogLine(null, "ERROR", trimmed),
            };
          }
          // ìŠ¤íƒíŠ¸ë ˆì´ìŠ¤ íŒ¨í„´ ê²€ì‚¬
          const stackPatterns = [
            /^\s*at\s+/, // "at " ì‹œì‘
            /\.js:\d+:\d+/, // .js:ì¤„ë²ˆí˜¸:ì»¬ëŸ¼ë²ˆí˜¸
            /\.ts:\d+:\d+/, // .ts:ì¤„ë²ˆí˜¸:ì»¬ëŸ¼ë²ˆí˜¸
            /node_modules/, // node_modules ê²½ë¡œ
            /\([^)]*:\d+:\d+\)/, // (íŒŒì¼:ì¤„:ì»¬ëŸ¼)
            /Error:\s/, // "Error: " ì‹œì‘
            /TypeError:\s/, // "TypeError: " ì‹œì‘
            /ReferenceError:\s/, // "ReferenceError: " ì‹œì‘
            /^\s*\^/, // í™”ì‚´í‘œ í¬ì¸í„°
            /^\s*~/, // í‹¸ë‹¤ í¬ì¸í„°
          ];
          const isStackTrace = stackPatterns.some((pattern) => pattern.test(trimmed));
          return {
            timestamp: null,
            level: isStackTrace ? "STACK_TRACE" : "CONTINUATION",
            message: trimmed,
            formatted: formatLogLine(
              null,
              isStackTrace ? "STACK_TRACE" : "CONTINUATION",
              trimmed
            ),
          };
        }

        const timestamp = timestampMatch[1];
        const afterTimestamp = message
          .substring(timestampMatch[0].length)
          .trim();

        // ë ˆë²¨ íŒ¨í„´: [INFO], [ERROR], [WARN]
        const levelRegex = /^\[([A-Z]+)\]/;
        const levelMatch = afterTimestamp.match(levelRegex);

        if (!levelMatch) {
          // ë ˆë²¨ì´ ì—†ëŠ” ê²½ìš° (ì—°ì† ë©”ì‹œì§€)
          return {
            timestamp: timestamp,
            level: "CONTINUATION",
            message: afterTimestamp,
            formatted: formatLogLine(timestamp, "CONTINUATION", afterTimestamp),
          };
        }

        const level = levelMatch[1];
        const logMessage = afterTimestamp
          .substring(levelMatch[0].length)
          .trim();

        const result = {
          timestamp: timestamp,
          level: level,
          message: logMessage,
          formatted: formatLogLine(timestamp, level, logMessage),
        };

        console.log("âœ… parseAndFormatLogMessage ê²°ê³¼:", result);
        return result;
      }

      // HTML ì´ìŠ¤ì¼€ì´í”„ í•¨ìˆ˜ (ReferenceError ë°©ì§€)
      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // ë¡œê·¸ ë¼ì¸ í¬ë§·íŒ…
      function formatLogLine(timestamp, level, message, stackTraces) {
        const timestampHtml = timestamp
          ? `<span class="log-timestamp">${timestamp}</span>`
          : "";

        const levelClass = level.toLowerCase();
        const levelHtml = `<span class="log-level ${level}">${level}</span>`;

        let messageHtml = "";
        if (level === "ERROR") {
          // ERROR ë©”ì‹œì§€ ê°€ë…ì„± ê°œì„ : ì—”ë“œí¬ì¸íŠ¸/ì—ëŸ¬/ì½”ë“œ ë¶„ë¦¬
          // ì˜ˆ: "ERROR: POST ... | IP: ... | Error: ... | Code: ..."
          // â†’ [ì—”ë“œí¬ì¸íŠ¸/ë©”ì„œë“œ] [Error: ...] [Code: ...] ë¸”ë¡ ë¶„ë¦¬
          const parts = message.split("|").map(s => s.trim());
          let main = "";
          let errorMsg = "";
          let codeMsg = "";
          let ipMsg = "";
          let others = [];
          for (const part of parts) {
            if (part.startsWith("Error:")) errorMsg = part;
            else if (part.startsWith("Code:")) codeMsg = part;
            else if (part.startsWith("IP:")) ipMsg = part;
            else if (part.startsWith("ERROR:")) main = part;
            else if (part.match(/^(POST|GET|PUT|DELETE|PATCH)\s/)) main = part;
            else others.push(part);
          }
          messageHtml = `<div class="log-message error-block">
            <div class="error-main">${escapeHtml(main || message)}</div>
            ${ipMsg ? `<div class="error-ip">${escapeHtml(ipMsg)}</div>` : ""}
            ${errorMsg ? `<div class="error-msg">${escapeHtml(errorMsg)}</div>` : ""}
            ${codeMsg ? `<div class="error-code">${escapeHtml(codeMsg)}</div>` : ""}
            ${others.length ? `<div class="error-etc">${others.map(escapeHtml).join("<br>")}</div>` : ""}
          </div>`;
        } else {
          messageHtml = `<span class="log-message">${escapeHtml(message)}</span>`;
        }
        if (Array.isArray(stackTraces) && stackTraces.length > 0) {
          messageHtml +=
            '<div class="stack-trace-container">' +
            stackTraces
              .map((line) => {
                const isStackTraceLine = /^\s*(at\s+|Error:|TypeError:|ReferenceError:|\s*\^|\s*~|ğŸ“)/.test(
                  line
                );
                const className = isStackTraceLine
                  ? "stack-trace-line"
                  : "continuation-line";
                return `<div class="${className}">${escapeHtml(
                  line.trim()
                )}</div>`;
              })
              .join("") +
            "</div>";
        }

        return `<div class="log-line ${levelClass}">
        ${timestampHtml}
        ${levelHtml}
        ${messageHtml}
    </div>`;
      }

      // ë°±ì—”ë“œì—ì„œ ì´ë¯¸ ë¸”ë¡ ë‹¨ìœ„ë¡œ ê·¸ë£¹í•‘ë¨ (ERROR_BLOCK, RESPONSE_BLOCK, LOG ë“±)
      // í”„ë¡ íŠ¸ëŠ” ë‹¨ìˆœíˆ ë¸”ë¡ì„ ë Œë”ë§ë§Œ í•˜ë©´ ë¨
// ... (ìœ„ì—ì„œ mergeConsecutiveLogs í•¨ìˆ˜ëŠ” ì´ë¯¸ ì˜¬ë°”ë¥´ê²Œ ì •ì˜ë¨. ì•„ë˜ ì¤‘ë³µ/ë¶ˆí•„ìš” ì½”ë“œ ì œê±°)

      // ë¡œê·¸ í•„í„°ë§ ë° ë Œë”ë§ (ë¸”ë¡ ë‹¨ìœ„)
      function filterLogs() {
        const level = levelFilter.value;
        const search = searchInput.value.toLowerCase();
        // logsToShowëŠ” allLogsì—ì„œ level/search í•„í„°ë§Œ ì ìš©
        let logsToShow = allLogs;
        if (level !== "all") {
          logsToShow = logsToShow.filter(log => (log.level || '').toUpperCase() === level.toUpperCase());
        }
        if (search) {
          logsToShow = logsToShow.filter(log => {
            return Object.values(log).some(v => typeof v === 'string' && v.toLowerCase().includes(search))
              || (Array.isArray(log.stack) && log.stack.some(s => s.toLowerCase().includes(search)))
              || (Array.isArray(log.etc) && log.etc.some(s => s.toLowerCase().includes(search)));
          });
        }
        // ë Œë”ë§
        const htmlContent = logsToShow.map((log) => renderLogBlock(log)).join("");
        logContent.innerHTML = htmlContent;
        // ìŠ¤í¬ë¡¤/ìë™ìŠ¤í¬ë¡¤ ìœ ì§€
        if (autoScroll) {
          setTimeout(() => scrollToBottom(), 50);
        }
      }

      // ë¸”ë¡ ë‹¨ìœ„ ë Œë”ë§ í•¨ìˆ˜
      function renderLogBlock(log) {
        if (log.type === 'ERROR_BLOCK') {
          // ì—ëŸ¬ ë¸”ë¡
          return `<div class="log-line error-block">
            <span class="log-timestamp">${escapeHtml(log.timestamp || '')}</span>
            <span class="log-level ERROR">ERROR</span>
            <div class="log-message">
              <div class="error-main">${escapeHtml(log.main || '')}</div>
              ${log.etc && log.etc.length ? `<div class="error-etc">${log.etc.map(escapeHtml).join('<br>')}</div>` : ''}
              ${log.stack && log.stack.length ? `<div class="stack-trace-container">${log.stack.map(line => `<div class="stack-trace-line">${escapeHtml(line)}</div>`).join('')}</div>` : ''}
            </div>
          </div>`;
        } else if (log.type === 'RESPONSE_BLOCK') {
          // ì‘ë‹µ/íƒ€ì„ì•„ì›ƒ ë¸”ë¡
          return `<div class="log-line ${log.level ? log.level.toLowerCase() : ''}">
            <span class="log-timestamp">${escapeHtml(log.timestamp || '')}</span>
            <span class="log-level ${log.level}">${escapeHtml(log.level || '')}</span>
            <span class="log-message">${escapeHtml(log.message || '')}</span>
          </div>`;
        } else {
          // ì¼ë°˜ ë¡œê·¸
          return `<div class="log-line ${log.level ? log.level.toLowerCase() : ''}">
            <span class="log-timestamp">${escapeHtml(log.timestamp || '')}</span>
            <span class="log-level ${log.level}">${escapeHtml(log.level || '')}</span>
            <span class="log-message">${escapeHtml(log.message || '')}</span>
          </div>`;
        }
      }

      // ê°œë³„ ë¡œê·¸ ì¶”ê°€ (ì‹¤ì‹œê°„ ê·¸ë£¹í•‘ ì§€ì›)
      function addSingleLog(logData) {
        try {
          console.log("â• ê°œë³„ ë¡œê·¸ ì¶”ê°€:", logData);

        // ì‹¤ì‹œê°„ ê·¸ë£¹í•‘: ì§ì „ ë¡œê·¸ê°€ ERRORì´ê³ , ìƒˆ ë¡œê·¸ê°€ STACK_TRACE/CONTINUATIONì´ë©´ push
        if (
            (logData.level === "STACK_TRACE" || logData.level === "CONTINUATION") &&
            allLogs.length > 0 &&
            allLogs[allLogs.length - 1].level === "ERROR"
        ) {
            const last = allLogs[allLogs.length - 1];
            if (!last.stackTraces) last.stackTraces = [];
            last.stackTraces.push(logData.message);
            // DOMì— ë°”ë¡œ append (UX ê°œì„ )
            const logContent = document.getElementById("logContent");
            const lastEntry = logContent.lastElementChild;
            if (lastEntry && lastEntry.classList.contains("error-block")) {
                // Error: ... ë¼ì¸ì€ error-msgë¡œ, at ... ë“±ì€ stack-traceë¡œ
                if (/^Error:/i.test(logData.message)) {
                    // error-msgê°€ ì´ë¯¸ ìˆìœ¼ë©´ ì¤‘ë³µ ì¶”ê°€ ë°©ì§€
                    let hasErrorMsg = false;
                    lastEntry.querySelectorAll('.error-msg').forEach(div => {
                        if (div.textContent === logData.message) hasErrorMsg = true;
                    });
                    if (!hasErrorMsg) {
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'error-msg';
                        errorMsg.textContent = logData.message;
                        lastEntry.appendChild(errorMsg);
                        errorMsg.classList.add('new-log');
                        setTimeout(() => errorMsg.classList.remove('new-log'), 500);
                    }
                } else {
                    let stackContainer = lastEntry.querySelector('.stack-trace-container');
                    if (!stackContainer) {
                        stackContainer = document.createElement('div');
                        stackContainer.className = 'stack-trace-container';
                        lastEntry.appendChild(stackContainer);
                    }
                    const stackLine = document.createElement('div');
                    stackLine.className = logData.level === "STACK_TRACE" ? 'stack-trace-line' : 'continuation-line';
                    stackLine.textContent = logData.message;
                    stackContainer.appendChild(stackLine);
                    stackLine.classList.add('new-log');
                    setTimeout(() => stackLine.classList.remove('new-log'), 500);
                }
                // ìë™ ìŠ¤í¬ë¡¤
                const wasScrolledToBottom = logContent.scrollTop + logContent.clientHeight >= logContent.scrollHeight - 50;
                if (autoScroll && wasScrolledToBottom) {
                  setTimeout(() => {
                    logContent.scrollTop = logContent.scrollHeight;
                  }, 10);
                }
                updateStats();
                return;
            } else {
                // fallback: ì „ì²´ ì¬ë Œë”ë§
                filterLogs();
                return;
            }
        }

          // ì¼ë°˜ ë¡œê·¸ëŠ” ê¸°ì¡´ ë°©ì‹ëŒ€ë¡œ ì¶”ê°€
          const logElement = document.createElement("div");
          logElement.innerHTML =
            formatLogLine(logData.timestamp, logData.level, logData.message, logData.stackTraces);
          logElement.className = "log-entry new-log";

          // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ í™•ì¸
          const wasScrolledToBottom =
            logContent.scrollTop + logContent.clientHeight >=
            logContent.scrollHeight - 50;

          // DOMì— ì¶”ê°€
          logContent.appendChild(logElement);

          // ìƒˆ ë¡œê·¸ ê°•ì¡° íš¨ê³¼ (0.5ì´ˆ í›„ ì œê±°)
          setTimeout(() => {
            logElement.classList.remove("new-log");
          }, 500);

          // ìë™ ìŠ¤í¬ë¡¤
          if (autoScroll && wasScrolledToBottom) {
            setTimeout(() => {
              scrollToBottom();
            }, 10);
          }

          console.log("âœ… ê°œë³„ ë¡œê·¸ ì¶”ê°€ ì™„ë£Œ");
        } catch (error) {
          console.error("ê°œë³„ ë¡œê·¸ ì¶”ê°€ ì‹¤íŒ¨:", error, logData);
          // ì‹¤íŒ¨ ì‹œ ì „ì²´ ì¬ë Œë”ë§
          filterLogs();
        }
      }

      // SSE ì—°ê²° ì‹œì‘
      function startSSE() {
        if (eventSource) {
          eventSource.close();
        }

        statusText.textContent = "ì—°ê²° ì¤‘...";
        statusIndicator.classList.remove("connected");
        connectionStatus.textContent = "ì—°ê²° ìƒíƒœ: ì—°ê²° ì¤‘...";

        eventSource = new EventSource("/api/logs/stream/live");

        eventSource.onopen = function () {
          statusText.textContent = "ì‹¤ì‹œê°„ ì—°ê²°ë¨";
          statusIndicator.classList.add("connected");
          connectionStatus.textContent = "ì—°ê²° ìƒíƒœ: ì‹¤ì‹œê°„ ìŠ¤íŠ¸ë¦¬ë°";
          connectionStatus.className = "connection-status connected";
        };

        eventSource.onmessage = function (event) {
          try {
            const logData = JSON.parse(event.data);
            if (logData.logs && Array.isArray(logData.logs)) {
              // ì´ˆê¸° ë¡œê·¸ ë°ì´í„° (í•œ ë²ˆë§Œ)
              console.log("ğŸ“¥ ì´ˆê¸° ë¡œê·¸ ë°ì´í„° ìˆ˜ì‹ :", logData.logs.length);
              allLogs = logData.logs.map((logItem) => {
                const message =
                  typeof logItem === "string"
                    ? logItem
                    : logItem.message || JSON.stringify(logItem);
                return parseAndFormatLogMessage(message);
              });
              filterLogs();
            } else if (logData.message) {
              // ìƒˆë¡œìš´ ë¡œê·¸ ë©”ì‹œì§€ (ê°œë³„ ì¶”ê°€)
              console.log("ğŸ“¨ ìƒˆ ë¡œê·¸ ë©”ì‹œì§€ ìˆ˜ì‹ :", logData.message);
              const message =
                typeof logData.message === "string"
                  ? logData.message
                  : JSON.stringify(logData.message);
              const parsed = parseAndFormatLogMessage(message);
              allLogs.push(parsed);

              // ë©”ëª¨ë¦¬ í•œê³„ ê´€ë¦¬ (ìµœëŒ€ 10000ê°œ)
              if (allLogs.length > 10000) {
                allLogs = allLogs.slice(-5000);
                console.log("ğŸ—‘ï¸ ë¡œê·¸ ë©”ëª¨ë¦¬ ì •ë¦¬: 5000ê°œë¡œ ì¶•ì†Œ");
              }

              // í•„í„°ë§ì´ 'all'ì´ê±°ë‚˜ ìƒˆ ë¡œê·¸ê°€ í•„í„°ì— ë§ìœ¼ë©´ ë°”ë¡œ í‘œì‹œ
              const level = levelFilter.value;
              const search = searchInput.value.toLowerCase();

              const shouldShow =
                (level === "all" || parsed.level === level) &&
                (!search || parsed.message.toLowerCase().includes(search));

              if (shouldShow) {
                // ê°œë³„ ë¡œê·¸ë§Œ ì¶”ê°€ (ì „ì²´ ì¬ë Œë”ë§ ë°©ì§€)
                addSingleLog(parsed);
              }

              updateStats();
            }
          } catch (e) {
            console.error("ë¡œê·¸ íŒŒì‹± ì˜¤ë¥˜:", e, event.data);
          }
        };

        eventSource.onerror = function () {
          statusText.textContent = "ì—°ê²° ì‹¤íŒ¨";
          statusIndicator.classList.remove("connected");
          connectionStatus.textContent = "ì—°ê²° ìƒíƒœ: ëŠì–´ì§";
          connectionStatus.className = "connection-status disconnected";

          // 3ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„
          setTimeout(() => {
            if (eventSource && eventSource.readyState === EventSource.CLOSED) {
              startSSE();
            }
          }, 3000);
        };
      }

      // ê¸°ì¡´ ë¡œê·¸ ë¡œë“œ
      async function loadExistingLogs() {
        try {
          const lines = linesLimit.value;
          const response = await fetch(
            `/api/logs/recent?lines=${lines}&level=all`
          );
          const data = await response.json();

          if (data.status === "success" && data.data && data.data.logs) {
            // ë¡œê·¸ ë°ì´í„° êµ¬ì¡° í™•ì¸ (ì „ì²´ ë°°ì—´ ê¸¸ì´ì™€ ìƒ˜í”Œ ë³´ê¸°)
            const logs = data.data.logs;
            console.log(`âœ… ë¡œê·¸ ë°ì´í„° ë¡œë“œ: ì´ ${logs.length}ê°œ`);
            console.log("ë¡œê·¸ ë°ì´í„° êµ¬ì¡° ìƒ˜í”Œ:", logs.slice(0, 5)); // 5ê°œ ìƒ˜í”Œë¡œ ì¦ê°€

            allLogs = logs.map((logItem, index) => {
              // ê°ì²´ì¸ ê²½ìš° raw ë˜ëŠ” message í”„ë¡œí¼í‹° ì‚¬ìš©, ì—†ìœ¼ë©´ ë¬¸ìì—´í™”
              if (typeof logItem === "object" && logItem !== null) {
                const message =
                  logItem.raw || logItem.message || JSON.stringify(logItem);
                const parsed = parseAndFormatLogMessage(message);

                // ì²˜ìŒ 3ê°œë§Œ ë””ë²„ê¹… ë¡œê·¸ ì¶œë ¥
                if (index < 3) {
                  console.log(
                    `ğŸ” ë¡œê·¸ ${index}: ì›ë³¸="${message.substring(
                      0,
                      80
                    )}..." â†’ íŒŒì‹±ê²°ê³¼=`,
                    parsed
                  );
                }

                return parsed;
              } else {
                // ë¬¸ìì—´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ íŒŒì‹±
                return parseAndFormatLogMessage(String(logItem));
              }
            });
            console.log(`ğŸ” íŒŒì‹± ì™„ë£Œ: ${allLogs.length}ê°œ ë¡œê·¸ ì²˜ë¦¬ë¨`);
            filterLogs();
          } else {
            showError("ë¡œê·¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          }
        } catch (error) {
          console.error("ë¡œê·¸ ë¡œë”© ì˜¤ë¥˜:", error);
          showError("ì„œë²„ ì—°ê²° ì˜¤ë¥˜");
        }
      }

      // í†µê³„ ì—…ë°ì´íŠ¸
      function updateStats() {
        const logStats = {
          total: filteredLogs.length,
          info: filteredLogs.filter((log) => log.level === "INFO").length,
          error: filteredLogs.filter((log) => log.level === "ERROR").length,
          warn: filteredLogs.filter((log) => log.level === "WARN").length,
        };

        document.getElementById("totalLogs").textContent = logStats.total;
        document.getElementById("infoCount").textContent = logStats.info;
        document.getElementById("errorCount").textContent = logStats.error;
        document.getElementById("warnCount").textContent = logStats.warn;
        document.getElementById("memoryCount").textContent = allLogs.length;
      }

      // í•„í„° ìƒíƒœ ì—…ë°ì´íŠ¸
      function updateFilterStatus() {
        const level = levelFilter.value;
        const search = searchInput.value;
        let status = "ì—†ìŒ";

        if (level !== "all" || search) {
          const filters = [];
          if (level !== "all") filters.push(level);
          if (search) filters.push(`"${search}"`);
          status = filters.join(", ");
        }

        document.getElementById("filterStatus").textContent = status;
      }

      // ìë™ ìŠ¤í¬ë¡¤ í† ê¸€
      function toggleAutoScroll() {
        autoScroll = !autoScroll;
        autoScrollBtn.classList.toggle("active", autoScroll);

        if (autoScroll) {
          scrollToBottom();
        }
      }

      // í•˜ë‹¨ìœ¼ë¡œ ìŠ¤í¬ë¡¤
      function scrollToBottom() {
        logContent.scrollTop = logContent.scrollHeight;
      }

      // ë¡œê·¸ ì§€ìš°ê¸°
      function clearLogs() {
        if (confirm("ëª¨ë“  ë¡œê·¸ë¥¼ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?")) {
          allLogs = [];
          filteredLogs = [];
          updateLogDisplay();
          updateStats();
        }
      }

      // ë¡œê·¸ ë‹¤ìš´ë¡œë“œ
      function downloadLogs() {
        window.open("/api/logs/download/api.log", "_blank");
      }

      // í˜„ì¬ ë¡œê·¸ ë‚´ë³´ë‚´ê¸°
      function exportLogs() {
        const content = filteredLogs
          .map((log) => `[${log.timestamp}] [${log.level}] ${log.message}`)
          .join("\n");

        const blob = new Blob([content], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `orbitmate-logs-${new Date()
          .toISOString()
          .slice(0, 19)}.txt`;
        a.click();
        URL.revokeObjectURL(url);
      }

      // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
      function showError(message) {
        logContent.innerHTML = `<div class="error-message">âŒ ${message}</div>`;
      }

      // ì •ê·œì‹ ì´ìŠ¤ì¼€ì´í”„
      function escapeRegex(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      // ë””ë°”ìš´ìŠ¤ í•¨ìˆ˜
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      levelFilter.addEventListener("change", filterLogs);
      searchInput.addEventListener("input", debounce(filterLogs, 300));
      linesLimit.addEventListener("change", loadExistingLogs);
      autoScrollBtn.addEventListener("click", toggleAutoScroll);
      clearBtn.addEventListener("click", clearLogs);
      refreshBtn.addEventListener("click", () => {
        location.reload();
      });
      downloadBtn.addEventListener("click", downloadLogs);
      exportBtn.addEventListener("click", exportLogs);

      // ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸ (ìë™ìŠ¤í¬ë¡¤ í•´ì œ)
      logContent.addEventListener("scroll", () => {
        const isAtBottom =
          logContent.scrollTop + logContent.clientHeight >=
          logContent.scrollHeight - 5;
        if (!isAtBottom && autoScroll) {
          autoScroll = false;
          autoScrollBtn.classList.remove("active");
        }
      });

      // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬
      window.addEventListener("beforeunload", function () {
        if (eventSource) {
          eventSource.close();
        }
      });

      // ì´ˆê¸°í™”
      document.addEventListener("DOMContentLoaded", function () {
        loadExistingLogs().then(() => {
          startSSE();
        });
      });
    </script>
  </body>
</html>
